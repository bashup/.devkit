#!/usr/bin/env bash
# ---
# This file is automatically generated from dk.md - DO NOT EDIT
# ---

# MIT License
#
# Copyright (c) 2017 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#!/bin/bash
shopt -q expand_aliases||{ unalias -a;shopt -s expand_aliases;};builtin alias\
	+='{ ::__;::(){ ((!$#))||{ shift;"${__dsl__[@]-::no-dsl}" '\
	~='{ ::__;::(){ ((!$#))||{ shift; ' -='"${__dsl__[@]-::no-dsl}" '\
	'{{=return;return;};__blk__=;set -- "${__blarg__[@]:1}"; ' '}}=};__:: 0 "$@";}'
eval 'dsl:(){ ((!$#))||local __dsl__=("$@");${__blk__:+::};};__bsp__=0
::__(){ __bstk__[__bsp__++]="${__blk__:+__blk__=1;$(declare -f ::)}";}
__::(){ local __blarg__=("$@");__blk__=1;:: "$@"||set -- $?;__blk__=;local REPLY;${__bstk__[--__bsp__]:+eval "${__bstk__[__bsp__]}"}||:;return $1;}'
#!/usr/bin/env bash

realpath.location(){ realpath.follow "$1"; realpath.absolute "$REPLY" ".."; }
realpath.resolved(){ realpath.follow "$1"; realpath.absolute "$REPLY"; }
realpath.dirname() { if [[ $1 =~ /+[^/]+/*$ ]]; then REPLY="${1%${BASH_REMATCH[0]}}"; REPLY=${REPLY:-/}; else REPLY=.; fi }
realpath.basename(){ if [[ $1 =~ /*([^/]+)/*$ ]]; then REPLY="${BASH_REMATCH[1]}"; else REPLY=/; fi }

realpath.follow() {
	local target
	while [[ -L "$1" ]] && target=$(readlink -- "$1"); do
		realpath.dirname "$1"
		# Resolve relative to symlink's directory
		[[ $REPLY != . && $target != /* ]] && REPLY=$REPLY/$target || REPLY=$target
		# Break out if we found a symlink loop
		for target; do [[ $REPLY == "$target" ]] && break 2; done
		# Add to the loop-detect list and tail-recurse
		set -- "$REPLY" "$@"
	done
	REPLY="$1"
}

realpath.absolute() {
	REPLY=$PWD; local eg=extglob; ! shopt -q $eg || eg=; ${eg:+shopt -s $eg}
	while (($#)); do case $1 in
		/*) REPLY=/; set -- "${1##+(/)}" "${@:2}" ;;
		*/*) set -- "${1%%/*}" "${1##${1%%/*}+(/)}" "${@:2}" ;;
		''|.) shift ;;
		..) realpath.dirname "$REPLY"; shift ;;
		*) REPLY="${REPLY%/}/$1"; shift ;;
	esac; done; ${eg:+shopt -u $eg}
}

realpath.canonical() {
	realpath.follow "$1"; set -- "$REPLY"   # $1 is now resolved
	realpath.basename "$1"; set -- "$1" "$REPLY"   # $2 = basename $1
	realpath.dirname "$1"
	[[ $REPLY != "$1" ]] && realpath.canonical "$REPLY"; # recurse unless root
	realpath.absolute "$REPLY" "$2";   # combine canon parent w/basename
}

realpath.relative() {
	local target=""
	realpath.absolute "$1"; set -- "$REPLY" "${@:2}"; realpath.absolute "${2-$PWD}" X
	while realpath.dirname "$REPLY"; [[ "$1" != "$REPLY" && "$1" == "${1#${REPLY%/}/}" ]]; do
		target=../$target
	done
	[[ $1 == "$REPLY" ]] && REPLY=${target%/} || REPLY="$target${1#${REPLY%/}/}"
	REPLY=${REPLY:-.}
}
# For documentation, see https://github.com/bashup/loco

set -euo pipefail

fn_exists() { declare -F -- "$1"; } >/dev/null
fn_copy()   { REPLY="$(declare -f "$1")"; eval "$2 ${REPLY#$1}"; }
findup()    { walkup "${1:-$PWD}" reply_if_exists "${@:2}"; }

reply_if_exists() {
    local pat dir=$1 IFS= ; shift
    for pat; do
        for REPLY in ${dir%/}/$pat; do [[ -f "$REPLY" ]] && return 0; done
    done
    return 1
}

walkup() {
    realpath.absolute "$1"
    until set -- "$REPLY" "${@:2}"; "$2" "$1" "${@:3}"; do
        [[ "$1" != "/" ]] || return 1; realpath.dirname "$1"
    done
}

_loco_usage() { loco_error "Usage: $LOCO_COMMAND command args..."; }
_loco_error() { echo "$@" >&2; exit 64; }
_loco_cmd() { REPLY="$LOCO_NAME.$1"; }
_loco_exec() { loco_error "Unrecognized command: $1"; }
_loco_exists() { type -t "$1"; } >/dev/null

_loco_do() {
    [[ "${1-}" ]] || loco_usage   # No command given, exit w/usage
    REPLY=""; loco_cmd "$1"; local cmd="$REPLY"
    [[ "$cmd" ]] || loco_usage   # Unrecognized command, exit w/usage

    if loco_exists "$cmd"; then
        # Command, alias, function, or builtin exists
        shift; "$cmd" "$@"
    else
        # Invoke the default command interpreter
        loco_exec "$@"
    fi
}

_loco_findproject() {
    # shellcheck disable=SC2015  # plain var assign can't be false
    findup "$LOCO_PWD" "${LOCO_FILE[@]}" && LOCO_PROJECT=$REPLY ||
        loco_error "Can't find $LOCO_FILE here";
}
_loco_preconfig() { true; }
_loco_postconfig() { true; }
_loco_findroot() { realpath.dirname "$LOCO_PROJECT"; LOCO_ROOT=$REPLY; }
_loco_loadproject() { cd "$LOCO_ROOT";  $LOCO_LOAD "$1"; }
_loco_site_config() { source "$1"; }
_loco_user_config() { source "$1"; }


# Find our configuration, exposing relevant paths and defaults

# shellcheck disable=SC2034  # some vars are only used by extending scripts
_loco_config() {
    LOCO_ARGS=("$@")
    loco_preconfig "$@"
    ${LOCO_COMMAND:+:} realpath.basename "$LOCO_SCRIPT"; LOCO_COMMAND="${LOCO_COMMAND-$REPLY}"
    LOCO_NAME="${LOCO_NAME-${LOCO_COMMAND}}"
    LOCO_PWD="${LOCO_PWD-$PWD}"

    LOCO_SITE_CONFIG="${LOCO_SITE_CONFIG-/etc/$LOCO_NAME/config}"
    [ -f "$LOCO_SITE_CONFIG" ] && loco_site_config "$LOCO_SITE_CONFIG"
    LOCO_RC="${LOCO_RC-.${LOCO_NAME}rc}"
    LOCO_USER_CONFIG="${LOCO_USER_CONFIG-$HOME/$LOCO_RC}"
    [ -f "$LOCO_USER_CONFIG" ] && loco_user_config "$LOCO_USER_CONFIG"

    [[ ${LOCO_FILE-} ]] || LOCO_FILE=(".$LOCO_NAME")
    LOCO_LOAD="${LOCO_LOAD-source}"
    loco_postconfig "$@"
}

_loco_main() {
    loco_config "$@"
    fn_exists "$LOCO_NAME" || eval "$LOCO_NAME() { loco_do \"\$@\"; }"
    ${LOCO_PROJECT:+:} loco_findproject "$@"
    ${LOCO_ROOT:+:}    loco_findroot "$@"
    loco_loadproject "$LOCO_PROJECT"
    loco_do "$@"
}

# Initialize default function implementations
for f in $(compgen -A function _loco_); do
    fn_exists "${f#_}" || fn_copy "$f" "${f#_}"
done

# Clear all LOCO_*  variables before beginning
for lv in ${!LOCO_@}; do unset "$lv"; done

LOCO_SCRIPT=$0
{ if [[ $OSTYPE != cygwin && $OSTYPE != msys && -e /dev/fd/0 ]]; then source /dev/fd/0; else source <(cat); fi; } <<'# --- EOF dotenv ---'
#!/usr/bin/env bash

__dotenv=
__dotenv_file=
__dotenv_cmd=.env

.env() {
	REPLY=()
	[[ $__dotenv_file || ${1-} == -* ]] || .env.--file .env || return
	if declare -F -- ".env.${1-}" >/dev/null; then .env."$@"; return ; fi
	.env --help >&2; return 64
}

.env.-f() { .env.--file "$@"; }
.env.-h() { .env.--help "$@"; }
.env.--help() {
	echo "Usage:
  $__dotenv_cmd [-f|--file FILE] COMMAND [ARGS...]
  $__dotenv_cmd -h|--help

Options:
  -f, --file FILE          Use a file other than .env

Read Commands:
  get KEY                  Get raw value of KEY (or fail)
  parse [KEY...]           Get trimmed KEY=VALUE lines for named keys (or all)
  export [KEY...]          Export the named keys (or all) in shell format

Write Commands:
  set [+]KEY[=VALUE]...    Set or unset values (in-place w/.bak); + sets default
  puts STRING              Append STRING to the end of the file
  generate KEY [CMD...]    Set KEY to the output of CMD unless it already exists;
                           return the new or existing value."
}

.env.get() {
	.env::arg "get requires a key" "$@" &&
	[[ "$__dotenv" =~ ^(.*(^|$'\n'))([ ]*)"$1="(.*)$ ]] &&
	REPLY=${BASH_REMATCH[4]%%$'\n'*} && REPLY=${REPLY%"${REPLY##*[![:space:]]}"}
}

.env.parse() {
	local line key
	while IFS= read -r line; do
		line=${line#"${line%%[![:space:]]*}"}  # trim leading whitespace
		line=${line%"${line##*[![:space:]]}"}  # trim trailing whitespace
		if [[ ! "$line" || "$line" == '#'* ]]; then continue ; fi
		if (($#)); then
			for key; do
				if [[ $key == "${line%%=*}" ]]; then REPLY+=("$line"); break;
				fi
			done
		else
			REPLY+=("$line")
		fi
	done <<<"$__dotenv"
	((${#REPLY[@]}))
}

.env.export() {	! .env.parse "$@" || export "${REPLY[@]}"; }

.env.set() {
	.env::file load || return ; local key saved=$__dotenv
	while (($#)); do
		key=${1#+}; key=${key%%=*}
		if .env.get "$key"; then
			REPLY=()
			if [[ $1 == +* ]]; then shift; continue  # skip if already found
			elif [[ $1 == *=* ]]; then
				__dotenv=${BASH_REMATCH[1]}${BASH_REMATCH[3]}$1$'\n'${BASH_REMATCH[4]#*$'\n'}
			else
				__dotenv=${BASH_REMATCH[1]}${BASH_REMATCH[4]#*$'\n'}
				continue   # delete all occurrences
			fi
		elif [[ $1 == *=* ]]; then
			__dotenv+="${1#+}"$'\n'
		fi
		shift
	done
	[[ $__dotenv == "$saved" ]] || .env::file save
}

.env.puts() { echo "${1-}">>"$__dotenv_file" && __dotenv+="$1"$'\n'; }

.env.generate() {
	.env::arg "key required for generate" "$@" || return
	.env.get "$1" && return || REPLY=$("${@:2}") || return
	.env::one "generate: ouptut of '${*:2}' has more than one line" "$REPLY" || return
	.env.puts "$1=$REPLY"
}

.env.--file() {
	.env::arg "filename required for --file" "$@" || return
	__dotenv_file=$1; .env::file load || return
	(($#<2)) || .env "${@:2}"
}

.env::arg() { [[ "${2-}" ]] || { echo "$__dotenv_cmd: $1" >&2; return 64; }; }

.env::one() { [[ "$2" != *$'\n'* ]] || .env::arg "$1"; }

.env::file() {
	local REPLY=$__dotenv_file
	case "$1" in
	load)
		__dotenv=; ! [[ -f "$REPLY" ]] || __dotenv="$(<"$REPLY")"$'\n' || return ;;
	save)
		if [[ -L "$REPLY" ]] && declare -F -- realpath.resolved >/dev/null; then
			realpath.resolved "$REPLY"
		fi
		{ [[ ! -f "$REPLY" ]] || cp -p "$REPLY" "$REPLY.bak"; } &&
		printf %s "$__dotenv" >"$REPLY.bak" && mv "$REPLY.bak" "$REPLY"
	esac
}

if [[ $BASH_SOURCE == "$0" ]]; then
	set -eu
	__dotenv_cmd=${0##*/}
	.env.export() { .env.parse "$@" || return 0; printf 'export %q\n' "${REPLY[@]}"; exit; }
	.env "$@" || exit $?
	${REPLY[@]+printf '%s\n' "${REPLY[@]}"}
fi
# --- EOF dotenv ---
#!/usr/bin/env bash
event(){ case $1 in error|quote|encode|decode);; *)
	__ev.encode "${2-}";local f n='' e=bashup_event_$REPLY'[1]';f=${e/event/flag}
	case $1 in emit) shift;${!f-};eval "${!e-}"; return ;;on|once|off|has)
		case "${3-}" in @_) n='$#';; @*[^0-9]*);; @[0-9]*) n=$((${3#@}));; esac; ${n:+
		set -- "$1" "$2" "${@:4}" }
		case $1/$# in
			on*/[12]) set -- error "${2-}: missing callback";; */[12]) REPLY=;;
			*) __ev.quote "${@:3}";((${n/\$#/1}))&&REPLY+=' "${@:2:'"$n"'}"';REPLY+=$'\n'
		esac
	esac
esac ;__ev."$@";}
__ev.error(){ echo "$1">&2;return "${2:-64}";}
__ev.quote(){ REPLY=; ${@+printf -v REPLY ' %q' "$@"}; REPLY=${REPLY# };}
__ev.has(){ [[ ${!e-} && $'\n'"${!e}" == *$'\n'"$REPLY"* && ! ${!f-} ]];}
__ev.get(){ ${!f-};REPLY=${!e-};}
__ev.on(){ __ev.has && return;if [[ ! ${!f-} ]];then eval "$e"+='$REPLY';else eval "${!e-};$REPLY";fi;}
__ev.off(){ __ev.has||return 0; n="${!e}"; n=${REPLY:+"${n#"$REPLY"}"}; eval "$e"=$'"${n//\n"$REPLY"/\n}"';[[ ${!e} ]]||unset "${e%\[1]}";}
__ev.fire(){ ${!f-};set -- "$e" "${@:2}"; while [[ ${!1-} ]];do eval "unset ${1%\[1]};${!1}"; done ;}
__ev.all(){ ${!f-};e=${!e-};eval "${e//$'\n'/||return; }";}
__ev.any(){ ${!f-};e=${!e-};eval "${e//$'\n'/&&return|| } ! :";}
__ev.resolve(){
	${!f-};__ev.fire "$@";__ev.quote "$@"
	printf -v n "eval __ev.error 'event \"%s\" already resolved' 70;return" "$1"; eval "${f}"='$n'
	printf -v n 'set -- %s' "$REPLY"; eval "${e}"='$n';readonly "${f%\[1]}" "${e%\[1]}"
}
__ev.resolved(){ [[ ${!f-} ]];}
__ev.once(){ n=${n:-0} n=${n/\$#/_}; event on "$1" "@$n" __ev_once $# "@$n" "$@";}
__ev_once(){ event off "$3" "$2" __ev_once "${@:1:$1+2}"; "${@:4}";}
__ev_jit(){
	local q r=${__ev_jit-} s=$1;((${#r}<250))||__ev_jit=
	while [[ "$s" ]]; do
		r=${s::1};s=${s:1};printf -v q %q "$r";eval 's=${s//'"$q}";printf -v r 'REPLY=${REPLY//%s/_%02x};' "${q/#[~]/[~]}" "'$r";eval "$r";__ev_jit+="$r"
	done
	eval '__ev.encode(){ local LC_ALL=C;REPLY=${1//_/_5f};'\
	"${__ev_jit-}"' [[ $REPLY != *[^_[:alnum:]]* ]] || __ev_jit "${REPLY//[_[:alnum:]]/}";}'
};__ev_jit ''
__ev.decode(){ REPLY=();while (($#));do printf -v n %b "${1//_/\\x}";REPLY+=("$n");shift;done;}
__ev.list(){ eval 'set -- "${!'"${e%\[1]}"'@}"';__ev.decode "${@#bashup_event_}";}
run() {
	if [[ ! ${DEVKIT_IS_PAGING-} ]] && event has "before_$1" paged-command; then
		dk use: tty
		with-pager run "$@"
		return
	elif event has "$1"; then
		event emit "before_$@"
		event emit "$@"
	elif fn_exists "dk.$1"; then
		event emit "before_$@"
		"dk.$@"
	elif event has "default_$1"; then
		event emit "before_$@"
		event emit "default_$@"
	else
		run "undefined-command" "$@"
		return
	fi
	event emit "after_$@"
}

dk.undefined-command() {
	abort "This project does not have a $1 command defined." 69   # EX_UNAVAILABLE
}

abort()    { log "$1"; exit "$2"; }
log()      { echo "$1" >&2; }

paged-command() { while (($#)); do before "$1" paged-command; shift; done; }

on() { if (($#==1)); then dsl: event-dsl on "$1";  else event on "$@"; fi; }
off(){ if (($#==1)); then dsl: event-dsl off "$1"; else event off "$@"; fi; }

before() { on "before_$@"; }
after()  { on "after_$@"; }

event-dsl() { [[ ! ${__blk__-} ]] || abort "Can't nest event blocks" 64; event "$@"; }
trap 'event emit "EXIT"' EXIT

# Commands that should have a bootstrap first:
for REPLY in setup update build cibuild dist server test console watch; do
    event once "before_$REPLY" dk bootstrap    # start everything but clean with bootstrap
done

# Commands that are ok as no-ops:
for REPLY in setup update bootstrap test_files; do
	on "default_$REPLY" :  # no-op
done

# Commands that should have tests run first:
for REPLY in build dist; do
	before "$REPLY" dk test
done

# Commands whose output should be paged
paged-command test

# Cleanup
clean-deps() { [[ "$BASHER_PREFIX" == "$PWD/.deps" ]] && rm -rf "$BASHER_PREFIX"; }

on    "clean" clean-deps
after "clean" hash -r
after "clean" linkbin .devkit/dk

on boot dk-fetch-deps
dk-fetch-deps() {
	local BUILD_DEPS; .env -f "package.sh" export BUILD_DEPS
	IFS=: read -ra BUILD_DEPS <<<"${BUILD_DEPS-}"; set -- ${BUILD_DEPS[@]+"${BUILD_DEPS[@]}"}
	for REPLY; do github "$REPLY"; done
}
basher() {
    require basher github basherpm/basher master bin/basher
    "$BASHER_INSTALL_BIN/basher" "$@"
}

github() {
	[[ $1 != *@* ]] || set -- "${1%%@*}" "${1#*@}" "${@:2}"
	[[ -d "$BASHER_PACKAGES_PATH/$1/.git" ]] && return
	mkdir -p "$BASHER_PACKAGES_PATH/$1"
	git clone -q --depth=1 ${2:+-b "$2"} "https://github.com/$1" "$BASHER_PACKAGES_PATH/$1"
	local BINS; .env -f "$BASHER_PACKAGES_PATH/$1/package.sh" export BINS
	IFS=: read -ra BINS <<<"${BINS-}"; set -- "$1" "${2-}" ${BINS[@]+"${BINS[@]}"} "${@:3}"
	for REPLY in "${@:3}"; do ${REPLY:+linkbin "$BASHER_PACKAGES_PATH/$1/$REPLY"}; done
}
go() { require-any go; unset -f go; command go "$@"; }
linkbin() {
    mkdir -p "$BASHER_INSTALL_BIN"
    relative-symlink "$1" "$BASHER_INSTALL_BIN/${2:-${1##*/}}"
    unhash "${2:-${1##*/}}"
}

catbin() {
    cat "${@:2}" >"$BASHER_INSTALL_BIN/$1"
    chmod +x "$BASHER_INSTALL_BIN/$1"
    unhash "$1"
}

unhash() { hash -d "$@" || true; } 2>/dev/null

have()     { [[ -x "$BASHER_INSTALL_BIN/$1" ]]; }
have-any() { unhash "$@"; command -v "$@"; } >/dev/null 2>&1

require() {
    have "$1" || __require "$1" "$1 must be installed to $BASHER_INSTALL_BIN/" "${@:2}"
}

require-any() {
    have-any "$1" || __require "$1" "Please install $1 to perform this operation" "${@:2}"
}

__require() {
    if (($#>2)); then "${@:3}"; unhash "$1"; else abort "$2" 69; fi
}

relative-symlink() {
    # Used to create relative links in .deps/bin
    realpath.dirname "$2"; realpath.relative "$1" "$REPLY"; ln -sf "$REPLY" "$2"; return $?
}
__find_dk_module() {
    local p
    for p in .devkit-modules .devkit/modules; do
        p=$LOCO_ROOT/$p/$1
        if [[ -f $p ]]; then REPLY=$p; return; fi
    done
    return 1
}

dk.use:() {
    while (($#)); do local m=$1; shift
        if [[ ${DEVKIT_MODULES-} == *"<$m>"* ]]; then
            : # already loaded
        elif __find_dk_module "$m"; then
            DEVKIT_MODULES+="<$m>"; source "$REPLY"
        else
            abort "Unknown module '$m'; maybe you need to update .devkit or install a dependency?" 69
        fi
    done
}
loco_preconfig() {
    LOCO_SCRIPT=${BASH_SOURCE[0]}
    LOCO_COMMAND=dk
    LOCO_FILE=(.dkrc)
}

loco_findroot() {
    local proj_dk this_dk
    _loco_findroot "$@"
    export DEVKIT_ROOT=$LOCO_ROOT DEVKIT_HOME=$LOCO_ROOT/.devkit
    realpath.canonical "$DEVKIT_HOME/dk"; proj_dk=$REPLY
    realpath.canonical "${BASH_SOURCE[0]}"; this_dk=$REPLY
    [[ "$proj_dk" == "$this_dk" || ! -x "$proj_dk" ]] || exec "$proj_dk" "$@";
}

loco_loadproject() {
    cd "$LOCO_ROOT"
    [[ -f .envrc ]] && source .envrc

    [[ ! "${BASHER_INSTALL_BIN-}" || ${BASHER_INSTALL_BIN#$PWD} == "$BASHER_INSTALL_BIN" ]] &&
        abort "Your .envrc must define a *local* installation of basher!" 78 # EX_CONFIG

    require dk linkbin "$DEVKIT_HOME/dk"   # make sure there's a local dk
    source "$1"
    event fire "boot"  # Run boot event as soon as soon as we're finished loading
}

loco_site_config() { :; }
loco_user_config() { :; }

loco_do() {
	if [[ "${1-}" ]]; then
		run "$@"  # try to run the event or function, plus before+after events
	else
		_loco_do "$@"  # empty subcommand, let loco abort w/error message
	fi
}
if [[ $0 == "${BASH_SOURCE-}" ]]; then loco_main "$@"; fi
