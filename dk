#!/usr/bin/env bash
# ---
# This file is automatically generated from dk.md - DO NOT EDIT
# ---

# MIT License
#
# Copyright (c) 2017 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#!/usr/bin/env bash

realpath.location() { realpath.follow "$1"; realpath.absolute "$REPLY" ".."; }
realpath.resolved() { realpath.follow "$1"; realpath.absolute "$REPLY"; }
realpath.dirname()  { if [[ $1 =~ /+[^/]+/*$ ]]; then REPLY="${1%${BASH_REMATCH}}"; REPLY=${REPLY:-/}; else REPLY=.; fi }
realpath.basename() { if [[ $1 =~ /*([^/]+)/*$ ]]; then REPLY="${BASH_REMATCH[1]}"; else REPLY=/; fi }

realpath.follow() {
	local target
	while [[ -L "$1" ]] && target=$(readlink -- "$1"); do
		realpath.dirname "$1"
		# Resolve symlink target relative to symlink's directory
		[[ $REPLY != . && $target != /* ]] && REPLY=$REPLY/$target || REPLY=$target
		# Break out if we found a symlink loop
		for target; do [[ $REPLY == "$target" ]] && break 2; done
		# Add current result to the loop-detect list and tail-recurse
		set -- "$REPLY" "$@"
	done
	REPLY="$1"
}

realpath.absolute() {
	REPLY=$PWD; local no_eg; shopt -q extglob || { no_eg=y; shopt -s extglob; }
	while (($#)); do case $1 in
		/*) REPLY=/; set -- "${1##+(/)}" "${@:2}" ;;
		*/*) set -- "${1%%/*}" "${1##${1%%/*}+(/)}" "${@:2}" ;;
		''|.) shift ;;
		..) realpath.dirname "$REPLY"; shift ;;
		*) REPLY="${REPLY%/}/$1"; shift ;;
	esac; done; ${no_eg:+shopt -u extglob}
}

realpath.canonical() {
	realpath.follow "$1"; set -- "$REPLY"   # $1 is now resolved
	realpath.basename "$1"; set -- "$1" "$REPLY"   # $2 = basename $1
	realpath.dirname "$1"
	[[ $REPLY != "$1" ]] && realpath.canonical "$REPLY"; # recurse unless root
	realpath.absolute "$REPLY" "$2";   # combine canon parent w/basename
}

realpath.relative() {
	local target=""
	realpath.absolute "$1"; set -- "$REPLY" "${@:2}"; realpath.absolute "${2-$PWD}" X
	while realpath.dirname "$REPLY"; [[ "$1" != "$REPLY" && "$1" == "${1#${REPLY%/}/}" ]]; do
		target=../$target
	done
	[[ $1 == "$REPLY" ]] && REPLY=${target%/} || REPLY="$target${1#${REPLY%/}/}"
	REPLY=${REPLY:-.}
}
# For documentation, see https://github.com/bashup/loco

set -euo pipefail

fn_exists() { declare -F -- "$1"; } >/dev/null
fn_copy()   { REPLY="$(declare -f $1)"; eval "$2 ${REPLY#$1}"; }
findup()    { walkup "${1:-$PWD}" reply_if_exists "${@:2}"; }

reply_if_exists() {
    local pat dir=$1 IFS= ; shift
    for pat; do
        for REPLY in ${dir%/}/$pat; do [[ -f "$REPLY" ]] && return 0; done
    done
    return 1
}

walkup() {
    realpath.absolute "$1"
    until set -- "$REPLY" "${@:2}"; "$2" "$1" "${@:3}"; do
        [[ "$1" != "/" ]] || return 1; realpath.dirname "$1"
    done
}

_loco_usage() { loco_error "Usage: $LOCO_COMMAND command args..."; }
_loco_error() { echo "$@" >&2; exit 64; }
_loco_cmd() { REPLY="$LOCO_NAME.$1"; }
_loco_exec() { loco_error "Unrecognized command: $1"; }
_loco_exists() { type -t "$1"; } >/dev/null

_loco_do() {
    [[ "${1-}" ]] || loco_usage   # No command given, exit w/usage
    REPLY=""; loco_cmd "$1"; local cmd="$REPLY"
    [[ "$cmd" ]] || loco_usage   # Unrecognized command, exit w/usage

    if loco_exists "$cmd"; then
        # Command, alias, function, or builtin exists
        shift; "$cmd" "$@"
    else
        # Invoke the default command interpreter
        loco_exec "$@"
    fi
}

_loco_findproject() {
    findup "$LOCO_PWD" "${LOCO_FILE[@]}" && LOCO_PROJECT=$REPLY ||
        loco_error "Can't find $LOCO_FILE here";
}
_loco_preconfig() { true; }
_loco_postconfig() { true; }
_loco_findroot() { realpath.dirname "$LOCO_PROJECT"; LOCO_ROOT=$REPLY; }
_loco_loadproject() { cd "$LOCO_ROOT";  $LOCO_LOAD "$1"; }
_loco_site_config() { source "$1"; }
_loco_user_config() { source "$1"; }


# Find our configuration, exposing relevant paths and defaults

_loco_config() {
    LOCO_ARGS=("$@")
    loco_preconfig "$@"
    ${LOCO_COMMAND:+:} realpath.basename "$LOCO_SCRIPT"; LOCO_COMMAND="${LOCO_COMMAND-$REPLY}"
    LOCO_NAME="${LOCO_NAME-${LOCO_COMMAND}}"
    LOCO_PWD="${LOCO_PWD-$PWD}"

    LOCO_SITE_CONFIG="${LOCO_SITE_CONFIG-/etc/$LOCO_NAME/config}"
    [ -f "$LOCO_SITE_CONFIG" ] && loco_site_config "$LOCO_SITE_CONFIG"
    LOCO_RC="${LOCO_RC-.${LOCO_NAME}rc}"
    LOCO_USER_CONFIG="${LOCO_USER_CONFIG-$HOME/$LOCO_RC}"
    [ -f "$LOCO_USER_CONFIG" ] && loco_user_config "$LOCO_USER_CONFIG"

    [[ ${LOCO_FILE-} ]] || LOCO_FILE=(".$LOCO_NAME")
    LOCO_LOAD="${LOCO_LOAD-source}"
    loco_postconfig "$@"
}

_loco_main() {
    loco_config "$@"
    fn_exists $LOCO_NAME || eval "$LOCO_NAME() { loco_do \"\$@\"; }"
    ${LOCO_PROJECT:+:} loco_findproject "$@"
    ${LOCO_ROOT:+:}    loco_findroot "$@"
    loco_loadproject "$LOCO_PROJECT"
    loco_do "$@"
}

# Initialize default function implementations
for f in $(compgen -A function _loco_); do
    fn_exists "${f#_}" || fn_copy "$f" "${f#_}"
done

# Clear all LOCO_*  variables before beginning
for lv in ${!LOCO_@}; do unset $lv; done

LOCO_SCRIPT=$0
#!/usr/bin/env bash
event() {
	case $1 in valid|quote|error|once);;
	*) local e=${2-} f n m=; e=${e%/*}; __ev.valid "$e"||m="Invalid event name '$e'"
		case $1$m in on|off|has)
			(($#>2))||m="${2-}: missing callback"; n=${2#$e} n=${n#/}
			case $n in _)n='$#';;*) n=$((n));; esac
			case $1${m:+_} in has_)m=;REPLY=;;*) __ev.quote "${@:3}";REPLY+=' "${@:2:'"$n"$'}"\n';; esac
		esac
		e=bashup_event_$e f=${e/event/flag}; ! [[ $m ]]||__ev.error "$m"||return
	esac
	__ev."$@"
}
__ev.error(){ echo "$1">&2;return ${2:-64};}
__ev.valid(){ [[ ${1-} =~ ^[_[:alnum:]]+$ ]];}
__ev.quote(){ REPLY=""; printf -v REPLY "${@+ %q}" "${@-}"; REPLY=${REPLY# };}
__ev.has(){ [[ ${!e-} && $'\n'"${!e}" == *$'\n'"$REPLY"* && ! ${!f-} ]];}
__ev.on(){ __ev.has && return;[[ ! ${!f-} ]]&&eval $e+='$REPLY'||eval "${!e-};$REPLY";}
__ev.off(){ __ev.has||return 0; n="${!e}"; n=${n#"$REPLY"}; eval $e=$'"${n//\n"$REPLY"/\n}"';}
__ev.emit(){ ${!f-};eval "${!e-}";}
__ev.fire(){ ${!f-};set -- "$e" "${@:2}"; while [[ ${!1-} ]];do eval "$1=;${!1}"; done ;}
__ev.all(){ ${!f-};e=${!e-};eval "${e//$'\n'/||return; }";}
__ev.any(){ ${!f-};e=${!e-};eval "${e//$'\n'/&&return|| } ! :";}
__ev.resolve(){
	${!f-};__ev.fire "$@";__ev.quote "$@"
	readonly $f="eval __ev.error 'event \"'$1'\" already resolved' 70;return" $e="set -- $REPLY"
}
__ev.resolved(){ [[ ${!f-} ]];}
__ev.once(){ event on "${1%/*}" event off "$@" && event on "$@";}
on() { event on "$@"; }
before() { event on "before_$@"; }
after()  { event on "after_$@"; }
emit() { event emit "$@"; }
run() { emit "before_$@"; emit "$@"; emit "after_$@"; }
command-event() { event has "$1" || undefined-command "$1"; run "$@"; }

dk.bootstrap() { event fire "boot"; }  # only run bootstrap callbacks once, can be no-op

# default commands
for REPLY in setup update build cibuild server test console clean files_changed; do
    eval "dk.$REPLY() { command-event $REPLY \"\$@\"; }"
    event once "before_$REPLY" dk bootstrap    # start everything with bootstrap
done

# Setup and update are ok as no-ops
on "default_setup"  :
on "default_update" :

# Test before build and cibuild
before "cibuild" dk test
before "build"   dk test

# Cleanup
clean_deps() { [[ "$BASHER_PREFIX" == "$PWD/.deps" ]] && rm -rf "$BASHER_PREFIX"; }

event off "before_clean" dk bootstrap   # don't bootstrap during clean
on    "clean" clean_deps
after "clean" hash -r
after "clean" linkbin .devkit/dk

undefined-command() {
    if event has "default_$1"; then
        emit "before_$@"; emit "default_$@"; emit "after_$@";
    else
        abort "This project does not have a $1 command defined." 69   # EX_UNAVAILABLE
    fi
}

abort()    { log "$1"; exit $2; }
log()      { echo "$1" >&2; }
basher() {
    require basher github basherpm/basher master bin/basher
    "$BASHER_INSTALL_BIN/basher" "$@"
}

github() {
    [[ -d "$BASHER_PACKAGES_PATH/$1/.git" ]] && return
    mkdir -p "$BASHER_PACKAGES_PATH/$1"
    git clone -q --depth=1 -b "${2:-master}" "https://github.com/$1" "$BASHER_PACKAGES_PATH/$1"
    local bin; for bin in "${@:3}"; do linkbin "$BASHER_PACKAGES_PATH/$1/$bin"; done
}
linkbin() {
    mkdir -p "$BASHER_INSTALL_BIN"
    relative-symlink "$1" "$BASHER_INSTALL_BIN/${2:-${1##*/}}"
    unhash "${2:-${1##*/}}"
}

catbin() {
    cat "${@:2}" >"$BASHER_INSTALL_BIN/$1"
    chmod +x "$BASHER_INSTALL_BIN/$1"
    unhash "$1"
}

unhash() { hash -d "$@" || true; } 2>/dev/null

have()     { [[ -x "$BASHER_INSTALL_BIN/$1" ]]; }
have-any() { unhash "$@"; command -v "$@"; } >/dev/null 2>&1

require() {
    have "$1" || __require "$1" "$1 must be installed to $BASHER_INSTALL_BIN/" "${@:2}"
}

require-any() {
    have-any "$1" || __require "$1" "Please install $1 to perform this operation" "${@:2}"
}

__require() {
    if (($#>2)); then "${@:3}"; unhash "$1"; else abort "$2" 69; fi
}

relative-symlink() {
    # Used to create relative links in .deps/bin
    realpath.dirname "$2"; realpath.relative "$1" "$REPLY"; ln -sf "$REPLY" "$2"; return $?
}
__find_dk_module() {
    local p
    for p in .devkit-modules .devkit/modules; do
        p=$LOCO_ROOT/$p/$1
        if [[ -f $p ]]; then REPLY=$p; return; fi
    done
    return 1
}

dk.use:() {
    while (($#)); do local m=$1; shift
        if [[ ${DEVKIT_MODULES-} == *"<$m>"* ]]; then
            : # already loaded
        elif __find_dk_module "$m"; then
            DEVKIT_MODULES+="<$m>"; source "$REPLY"
        else
            abort "Unknown module '$m'; maybe you need to update .devkit or install a dependency?" 69
        fi
    done
}
loco_preconfig() {
    LOCO_SCRIPT=$BASH_SOURCE
    LOCO_COMMAND=dk
    LOCO_FILE=.dkrc
}

loco_findroot() {
    local proj_dk this_dk
    _loco_findroot "$@"
    export DEVKIT_ROOT=$LOCO_ROOT DEVKIT_HOME=$LOCO_ROOT/.devkit
    realpath.canonical "$DEVKIT_HOME/dk"; proj_dk=$REPLY
    realpath.canonical "$BASH_SOURCE"; this_dk=$REPLY
    [[ "$proj_dk" == "$this_dk" || ! -x "$proj_dk" ]] || exec "$proj_dk" "$@";
}

loco_loadproject() {
    cd "$LOCO_ROOT"
    [[ -f .envrc ]] && source .envrc

    [[ ! "${BASHER_INSTALL_BIN-}" || ${BASHER_INSTALL_BIN#$PWD} == "$BASHER_INSTALL_BIN" ]] &&
        abort "Your .envrc must define a *local* installation of basher!" 78 # EX_CONFIG

    require dk linkbin "$DEVKIT_HOME/dk"   # make sure there's a local dk
    $LOCO_LOAD "$1"
}
loco_site_config() { :; }
loco_user_config() { :; }
if [[ $0 == "${BASH_SOURCE-}" ]]; then loco_main "$@"; fi
